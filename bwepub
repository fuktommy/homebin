#!/usr/bin/python3
"""Edit comic epub generated by Bookwalker.
"""
#
# Copyright (c) 2023 Satoshi Fukutomi <info@fuktommy.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
import argparse
import os
import shutil
import sys
import tempfile
import time
import uuid
import zipfile

def parse_args(argv):
    parser = argparse.ArgumentParser(
        description='Edit comic epub generated by Bookwalker.')
    parser.add_argument('input', help='input epub file')
    parser.add_argument('output', help='output epub file')
    parser.add_argument('-a', '--author', dest='author',
                        default='author',
                        help='author name')
    parser.add_argument('-p', '--publisher', dest='publisher',
                        default='publisher',
                        help='publisher name')
    return parser.parse_args(argv)

def remove_bw_files(dir):
    os.remove(os.path.join(dir, 'item/image/bookwalker.jpg'))
    os.remove(os.path.join(dir, 'item/xhtml/p-bookwalker.xhtml'))

def update_opf(dir, author, publisher):
    with open(os.path.join(dir, 'item/standard.opf')) as f:
        lines = f.read().split('\n')
    for i, line in enumerate(lines):
        if line.startswith('<dc:creator'):
            lines[i] = '<dc:creator id="creator01">%s</dc:creator>' % author
        if line.startswith('<dc:publisher'):
            lines[i] = ('<dc:publisher id="publisher">%s</dc:publisher>'
                % publisher)
        if line.startswith('<dc:identifier'):
            lines[i] = ('<dc:identifier id="jdcn">%s</dc:identifier>'
                % uuid.uuid4())
        if line.startswith('<meta property="dcterms:modified">'):
            lines[i] = ('<meta property="dcterms:modified">%s</meta>'
                % time.strftime('%Y-%m-%dT%H:%M:%SZ', time.gmtime()))
        if 'image/bookwalker.jpg' in line:
            lines[i] = ''
        if 'xhtml/p-bookwalker.xhtml' in line:
            lines[i] = ''
        if 'xhtml-p-bookwalker' in line:
            lines[i] = ''
    with open(os.path.join(dir, 'item/standard.opf'), 'w') as f:
        lines = f.write('\n'.join(lines))

def archive(dir, output):
    with zipfile.ZipFile(output, 'w', compression=zipfile.ZIP_STORED) as zf:
        zf.write(os.path.join(dir, 'mimetype'), arcname='mimetype')

    with zipfile.ZipFile(output, 'a',
            compression=zipfile.ZIP_DEFLATED,
            compresslevel=9) as zf:
        for root, dirs, files in os.walk(dir):
            r = os.path.relpath(root, dir)
            for f in files:
                if f == 'mimetype':
                    continue
                zf.write(os.path.join(root, f), arcname=os.path.join(r, f))

def _main():
    args = parse_args(sys.argv[1:])
    with tempfile.TemporaryDirectory() as tmpdir:
        shutil.unpack_archive(args.input, tmpdir, 'zip')
        remove_bw_files(tmpdir)
        update_opf(tmpdir, args.author, args.publisher)
        archive(tmpdir, args.output)

if __name__ == '__main__':
    _main()

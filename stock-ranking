#!/usr/bin/python
"""Stock ranking using http://k-db.com/
"""
#
# Copyright (c) 2013 Satoshi Fukutomi <info@fuktommy.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

from __future__ import division
import codecs
import csv
import math
import optparse
import os
import sys
import time
import urllib2


def parse_args(argv):
    """Parse command line argments.
    """
    default_workdir = os.path.expanduser('~/.stock-ranking')
    usage = 'usage: %prog [options] [string...]'
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-d', '--workdir', dest='workdir',
                      default=default_workdir, metavar='PATH',
                      help='working directory')
    parser.add_option('-e', '--encode', dest='output_encode',
                      default='utf-8',
                      help='output_encoding')
    parser.add_option('-f', '--fetch', action='store_true', default=False,
                      dest='do_fetch',
                      help='fetch from http://k-db.com/')
    parser.add_option('-r', '--remove', action='store_true', default=False,
                      dest='do_remove',
                      help='remove old files')
    return parser.parse_args(argv)


class DataSource(object):
    def __init__(self, date, workdir):
        """Create data source by date(YYYY-MM-DD)
        """
        self.date = date
        self.workdir = workdir
        self.basename = '%s_all.csv' % date
        self.path = os.path.join(workdir, self.basename)
        self.url = ('http://k-db.com/site/download.aspx'
                 + '?p=all&download=csv&date=' + date)

    def is_fetched(self):
        return os.path.isfile(self.path)

    def fetch(self):
        sys.stderr.write('fetching %s\n' % self.url)
        buf = urllib2.urlopen(self.url).read()
        if not buf.startswith(self.date):
            sys.stderr.write('skip %s\n' % self.url)
        if not os.path.isdir(self.workdir):
            os.makedirs(self.workdir)
        open(self.path, 'w').write(buf)
        time.sleep(1)


def get_dates(now):
    dates = []
    for i in xrange(0, 56):
        d = now - i * 24 * 60 * 60
        day = time.strftime('%w', time.localtime(d))
        if day in ('0', '6'):
            # Sunday or Saturday
            continue
        dates.append(time.strftime('%Y-%m-%d', time.localtime(d)))
    dates.reverse()
    return dates

def remove_old_files(sources, workdir):
    if not os.path.isdir(workdir):
        return
    expected_files = [s.basename for s in sources]
    for f in os.listdir(workdir):
        if f not in expected_files:
            path = os.path.join(workdir, f)
            sys.stderr.write('removing %s\n' % path)
            os.remove(path)


class Stock(object):
    def __init__(self, code, name):
        self.code = code
        self.name = name
        self.point = 0
        self.count = 0
        self.sum = 0
        self.index = 10
        self.last_average = -1
        self.history = []

    def add(self, min, max, turnover, sales):
        if min < 100:
            self.point -= 10000
            return
        if turnover / min < 10:
            self.point -= 10000
            return
        average = sales / turnover
        if self.last_average > 0:
            diff = (average - self.last_average) / self.last_average
            self.history.append(diff)
            self.sum += abs(diff)
            self.count += 1
            self.index += 1
            if self.sum > 0:
                point = diff / (self.sum / self.count) * self.index
            else:
                point = 0
            if diff < 0:
                self.point += point * 2
            else:
                self.point += point
        self.last_average = average
        self.last_min = min
        self.last_max = max
        self.count += 1

    def finalize(self):
        if self.history:
            average = sum(self.history) / len(self.history)
            dist = sum([(average - d) ** 2 for d in self.history])
            devi = math.sqrt(dist)
            self.point -= devi * self.index * 10

    def get_kcom_code(self):
        return (self.code.replace('-', '.')
                .replace('.O', '.OS')
                .replace('.J', '.OS')
                .replace('.S', '.SP'))

    def get_kcom_url(self):
        return ('http://s20.si0.kabu.co.jp/Members/Tradetool/investment_info/?'
                + 'trid=600&trric=' + self.get_kcom_code())


class StockMap(object):
    def __init__(self):
        self.map = {}

    def _strtoint(self, str):
        if str == '' or str == '-':
            return -1
        else:
            return int(str)

    def read(self, csvfile):
        for row in csv.reader(open(csvfile)):
            try:
                code = row[0]
                name = row[1].decode('sjis')
                max = self._strtoint(row[5])
                min = self._strtoint(row[6])
                turnover = self._strtoint(row[8])
                sales = self._strtoint(row[9])
            except (IndexError, ValueError):
                continue
            if code not in self.map:
                self.map[code] = Stock(code, name)
            self.map[code].add(min, max, turnover, sales)

    def finalize(self):
        for code in self.map:
            self.map[code].finalize()

    def get_ranking(self, limit = 30):
        codes = self.map.keys()
        codes.sort(lambda a, b:
            int((self.map[b].point - self.map[a].point) * 1000))
        return [self.map[c] for c in codes[0:limit]]


def _main():
    options, args = parse_args(sys.argv[1:])
    sys.stdout = codecs.getwriter(options.output_encode)(sys.stdout)
    workdir = options.workdir
    sources = [DataSource(d, workdir) for d in get_dates(time.time())]
    if options.do_remove:
        remove_old_files(sources, workdir)
    stock_map = StockMap()
    for s in sources:
        if options.do_fetch and not s.is_fetched():
            s.fetch()
        if s.is_fetched():
            stock_map.read(s.path)
    stock_map.finalize()
    for s in stock_map.get_ranking():
        print s.point, s.name, s.get_kcom_url()

if __name__ == '__main__':
    _main()

#!/usr/bin/python
"""Daily summarize values.

input:
    2012-10-01 00:00:00    30
    2012-10-01 01:00:00    40
output:
    2012-10-01    35    40  # 35:average, 40: maximum
"""
#
# Copyright (c) 2012 Satoshi Fukutomi <info@fuktommy.com>.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#
import datetime
import fileinput
import optparse
import os
import shutil
import sqlite3
import sys


class SampleValue(object):
    def __init__(self, date, time, value):
        self.date = date
        self.time = time
        self.value = value


class Summary(object):
    def __init__(self, date, average, maximum):
        self.date = date.encode('utf-8')
        self.average = average
        self.maximum = maximum


class Storage(object):
    def __init__(self, dbpath):
        self.dbpath = dbpath
        db_exists = os.path.isfile(dbpath)
        self.con = sqlite3.connect(self.dbpath)
        self.con.isolation_level = 'DEFERRED'
        if not db_exists:
            self._create_tables()

    def _create_tables(self):
        self.con.executescript("""
            CREATE TABLE `values` (
              `sampletime` TEXT PRIMARY KEY NOT NULL,
              `date` TEXT NOT NULL,
              `value` INTEGER NOT NULL
            );
            CREATE INDEX `date` ON `values` (`date`);
            CREATE TABLE `summary` (
              `date` TEXT PRIMARY KEY NOT NULL,
              `average` INTEGER NOT NULL,
              `maximum` INTEGER NOT NULL
            );
        """)

    def _add_value(self, cur, date, time, value):
        cur.execute("""
            INSERT OR REPLACE INTO `values`
              (`sampletime`, `date`, `value`)
              VALUES (?, ?, ?);
            """, ['%s %s' % (date, time), date, value])

    def _summarize(self, date):
        cur = self.con.cursor()
        cur.execute("""
            SELECT
              AVG(`value`),
              MAX(`value`)
            FROM `values`
            WHERE `date` = ?;
            """, [date])
        average, maximum = cur.fetchone()
        cur.close()

        cur = self.con.cursor()
        cur.execute("""
            INSERT OR REPLACE INTO `summary`
              (`date`, `average`, `maximum`)
              VALUES (?, ?, ?)
            """, [date, average, maximum])
        cur.close()

    def append(self, values):
        dates = set()

        cur = self.con.cursor()
        for v in values:
            self._add_value(cur, v.date, v.time, v.value)
            dates.add(v.date)
        cur.close()

        for date in dates:
            self._summarize(date)

        self.con.commit()

    def backup(self):
        if not os.path.isfile(self.dbpath):
            return
        dst = '%s.%s' % (
            self.dbpath,
            datetime.date.today().strftime('%Y-%m-%d'))
        if os.path.isfile(dst):
            os.remove(dst)
        shutil.copy2(self.dbpath, dst)

    def get_summary(self):
        cur = self.con.cursor()
        cur.execute("""
            SELECT `date`, `average`, `maximum`
            FROM `summary`
            ORDER BY `date`
            """)
        ret = []
        for r in cur.fetchall():
            ret.append(Summary(r[0], r[1], r[2]))
        cur.close()
        return ret

    def close(self):
        self.con.close()


def parse_args(argv):
    usage = 'usage: %prog [options] [file...]'
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('-s', '--storage', dest='storage_file',
                      help='sqlite3 storage file.')
    parser.add_option('-u', '--update', dest='update_mode',
                      default=False, action='store_true',
                      help='update mode.')
    parser.add_option('-q', '--quiet', dest='quiet_mode',
                      default=False, action='store_true',
                      help='do not print summary.')
    return parser.parse_args(argv)


def _main():
    options, files = parse_args(sys.argv[1:])
    if not options.storage_file:
        storage = Storage(':memory:')
    elif options.update_mode:
        storage = Storage(options.storage_file)
        storage.backup()
    else:
        storage = Storage(options.storage_file)

    if options.update_mode:
        values = []
        for line in fileinput.input(files):
            date, time, value = line.strip().split()
            values.append(SampleValue(date, time, value))
        storage.append(values)

    if not options.quiet_mode:
        for summary in storage.get_summary():
            print '%s\t%d\t%d' % (
                summary.date, summary.average, summary.maximum)

    storage.close()

_main()
